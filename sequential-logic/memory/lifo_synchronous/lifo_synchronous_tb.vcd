$date
	Fri May 19 04:14:25 2023
$end
$version
	Icarus Verilog
$end
$timescale
	100ps
$end
$scope module LIFO_SYNCHRONOUS_TB $end
$var wire 1 ! FULL $end
$var wire 1 " EMPTY $end
$var wire 8 # DATA_OUT [7:0] $end
$var parameter 32 $ CLKPERIOD $end
$var reg 1 % CLK $end
$var reg 256 & COMMENT [255:0] $end
$var reg 8 ' DATA_IN [7:0] $end
$var reg 8 ( DATA_OUTEXP [7:0] $end
$var reg 1 ) EMPTYEXP $end
$var reg 32 * ERRORS [31:0] $end
$var reg 1 + FULLEXP $end
$var reg 1 , RE $end
$var reg 1 - RST $end
$var reg 32 . VECTORCOUNT [31:0] $end
$var reg 1 / WE $end
$var integer 32 0 COUNT [31:0] $end
$var integer 32 1 FD [31:0] $end
$scope module UUT_lifo_synchronous_structural $end
$var wire 1 % clk $end
$var wire 8 2 data_in [7:0] $end
$var wire 1 , re $end
$var wire 1 - rst $end
$var wire 1 / we $end
$var wire 1 3 w_next $end
$var wire 4 4 stack_ptr [3:0] $end
$var wire 1 5 r_next $end
$var wire 1 ! full $end
$var wire 1 " empty $end
$var wire 8 6 data_out [7:0] $end
$var parameter 1 7 zero $end
$var parameter 8 8 zeros $end
$scope module compare_and_status_logic $end
$var wire 4 9 stack_ptr [3:0] $end
$var parameter 4 : depth $end
$var reg 1 " empty $end
$var reg 1 ! full $end
$upscope $end
$scope module dual_port_ram_synchronous $end
$var wire 1 % clk $end
$var wire 8 ; data_in_A [7:0] $end
$var wire 8 < data_in_B [7:0] $end
$var wire 8 = data_out_A [7:0] $end
$var wire 8 > data_out_B [7:0] $end
$var wire 1 / we_A $end
$var wire 1 ? we_B $end
$var wire 4 @ addr_B [3:0] $end
$var wire 4 A addr_A [3:0] $end
$var reg 4 B address_register_A [3:0] $end
$var reg 4 C address_register_B [3:0] $end
$upscope $end
$scope module read_logic $end
$var wire 1 " empty $end
$var wire 1 , re $end
$var reg 1 5 r_next $end
$upscope $end
$scope module stack_ptr_control $end
$var wire 1 % clk $end
$var wire 1 5 r_next $end
$var wire 1 - rst $end
$var wire 1 3 w_next $end
$var reg 4 D stack_ptr [3:0] $end
$upscope $end
$scope module write_logic $end
$var wire 1 ! full $end
$var wire 1 / we $end
$var reg 1 3 w_next $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b1111 :
b0 8
07
b10100 $
$end
#0
$dumpvars
bx D
bx C
bx B
bx A
bx @
0?
bx >
bx =
b0 <
bx ;
bx 9
bx 6
05
bx 4
03
bx 2
b10000000000000000000000000000011 1
b1000 0
0/
b0 .
0-
0,
x+
b0 *
x)
bx (
bx '
b1001001010011100100100101010100 &
0%
bx #
x"
x!
$end
#100
1%
#200
0%
#250
b1 .
1)
0+
1-
b101001001000101010100110100010101010100 &
#300
1"
0!
b0 4
b0 9
b0 @
b0 A
b0 D
1%
#400
0%
#450
13
b10 .
b1111 (
0)
b1111 '
b1111 2
b1111 ;
1/
0-
b10100000101010101010011010010000010110100110001 &
#500
0"
b1111 #
b1111 6
b1111 >
b0 C
b1 4
b1 9
b1 @
b1 A
b1 D
1%
#600
0%
#650
b11 .
b11110000 (
b11110000 '
b11110000 2
b11110000 ;
b10100000101010101010011010010000010110100110010 &
#700
b10 4
b10 9
b10 @
b10 A
b10 D
b11110000 #
b11110000 6
b11110000 >
b1 C
1%
#800
0%
#850
b100 .
b10101010 (
b10101010 '
b10101010 2
b10101010 ;
b10100000101010101010011010010000010110100110011 &
#900
b10101010 #
b10101010 6
b10101010 >
b10 C
b11 4
b11 9
b11 @
b11 A
b11 D
1%
#1000
0%
#1050
03
b101 .
bx '
bx 2
bx ;
0/
b101101 &
#1100
bx #
bx 6
bx >
b11 C
b11 B
1%
#1150
b1 *
#1200
0%
#1250
b110 .
#1300
1%
#1350
b10 *
#1400
0%
#1450
b111 .
#1500
1%
#1550
b11 *
#1600
0%
#1650
b1000 .
#1700
1%
#1750
b100 *
#1800
0%
#1850
b1001 .
#1900
1%
#1950
b101 *
#2000
0%
#2050
b1010 .
#2100
1%
#2150
b110 *
#2200
0%
#2250
b1011 .
#2300
1%
#2350
b111 *
#2400
0%
#2450
b1100 .
#2500
1%
#2550
b1000 *
#2600
0%
#2650
15
b1101 .
b11110000 (
1,
b101000001001111010100000010110100110011 &
#2700
b10 4
b10 9
b10 @
b10 A
b10 D
1%
#2750
b1001 *
#2800
0%
#2850
b1110 .
b1111 (
1)
b101000001001111010100000010110100110010 &
#2900
b10101010 =
b10 B
b10101010 #
b10101010 6
b10101010 >
b10 C
b1 4
b1 9
b1 @
b1 A
b1 D
1%
#2950
b1010 *
#3000
0%
#3050
b1111 .
b101000001001111010100000010110100110001 &
#3100
05
1"
b0 4
b0 9
b0 @
b0 A
b0 D
b11110000 #
b11110000 6
b11110000 >
b1 C
b11110000 =
b1 B
1%
#3150
b1011 *
#3200
0%
#3250
b11111111111111111111111111111111 0
